/*
 * Copyright 2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.mx.ymate.mqtt.impl;

import cn.hutool.setting.dialect.PropsUtil;
import com.mx.ymate.mqtt.IMqtt;
import com.mx.ymate.mqtt.IMqttConfig;
import net.ymate.platform.commons.lang.BlurObject;
import net.ymate.platform.commons.util.DateTimeUtils;
import net.ymate.platform.commons.util.UUIDUtils;
import net.ymate.platform.core.configuration.IConfigReader;
import net.ymate.platform.core.module.IModuleConfigurer;
import net.ymate.platform.log.Logs;
import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.lang3.StringUtils;
import org.eclipse.paho.client.mqttv3.MqttCallback;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Properties;

import static com.mx.ymate.mqtt.MqttConstant.MQTT_VERSION_3_1_1;
import static org.eclipse.paho.client.mqttv3.MqttConnectOptions.*;

/**
 * DefaultMqttConfig generated By ModuleMojo on 2024/04/07 11:19
 *
 * @author YMP (https://www.ymate.net/)
 */
public final class DefaultMqttConfig implements IMqttConfig {

    private boolean enabled = true;

    private boolean autoConnect = true;

    private boolean initialized;

    private String url;

    private String clientId;

    private String userName;

    private String password;

    private boolean cleanSession;

    private boolean manualAcks;

    private int connectionTimeout;

    private int keepAliveInterval;

    private int maxInflight;

    private String version;

    private boolean automaticReconnection;

    private int reconnectDelay;

    private Properties sslProperties;

    private String storageDir;

    private String willTopic;

    private String willPayload;

    private int willQos;

    private boolean willRetained;

    public static DefaultMqttConfig defaultConfig() {
        return builder().build();
    }

    public static DefaultMqttConfig create(IModuleConfigurer moduleConfigurer) {
        return new DefaultMqttConfig(null, moduleConfigurer);
    }

    public static DefaultMqttConfig create(Class<?> mainClass, IModuleConfigurer moduleConfigurer) {
        return new DefaultMqttConfig(mainClass, moduleConfigurer);
    }

    public static Builder builder() {
        return new Builder();
    }

    private DefaultMqttConfig() {
    }

    private DefaultMqttConfig(Class<?> mainClass, IModuleConfigurer moduleConfigurer) {
        IConfigReader configReader = moduleConfigurer.getConfigReader();
        enabled = configReader.getBoolean(ENABLED, true);
        autoConnect = configReader.getBoolean(AUTO_CONNECT, true);
        url = configReader.getString(URL);
        clientId = configReader.getString(CLIENT_ID);
        if (clientId.contains("{time}")) {
            clientId = clientId.replace("{time}", BlurObject.bind(DateTimeUtils.currentTimeMillis()).toStringValue());
        } else if (clientId.contains("{uuid}")) {
            clientId = clientId.replace("{uuid}", UUIDUtils.UUID());
        }
        if (StringUtils.isBlank(clientId)) {
            clientId = "mqttClientId-" + UUIDUtils.UUID();
        }
        userName = configReader.getString(USER_NAME);
        password = configReader.getString(PASSWORD);
        cleanSession = configReader.getBoolean(CLEAN_SESSION, CLEAN_SESSION_DEFAULT);
        manualAcks = configReader.getBoolean(MANUAL_ACKS, false);
        connectionTimeout = configReader.getInt(CONNECTION_TIMEOUT, CONNECTION_TIMEOUT_DEFAULT);
        keepAliveInterval = configReader.getInt(KEEP_ALIVE_INTERVAL, KEEP_ALIVE_INTERVAL_DEFAULT);
        maxInflight = configReader.getInt(MAX_INFLIGHT, MAX_INFLIGHT_DEFAULT);
        version = configReader.getString(VERSION, MQTT_VERSION_3_1_1);
        automaticReconnection = configReader.getBoolean(AUTOMATIC_RECONNECTION, false);
        reconnectDelay = configReader.getInt(RECONNECT_DELAY, 128000);
        String sslPath = configReader.getString(SSL_PROPERTIES);
        if (StringUtils.isNotBlank(sslPath)) {
            Properties p = new Properties();
            try {
                p.load(new FileInputStream(sslPath));
                this.sslProperties = p;
            } catch (FileNotFoundException e) {
                Logs.get().getLogger().error("MQTT SSL配置文件未找到,请检查文件[" + sslPath + "]是否存在", e);
            } catch (IOException e) {
                Logs.get().getLogger().error("MQTT SSL配置文件[" + sslPath + "]读取失败", e);
            }
        }
        storageDir = configReader.getString(STORAGE_DIR);
        willTopic = configReader.getString(WILL_TOPIC);
        willPayload = configReader.getString(WILL_PAYLOAD);
        willQos = configReader.getInt(WILL_QOS);
        willRetained = configReader.getBoolean(WILL_RETAINED);

    }

    @Override
    public void initialize(IMqtt owner) throws Exception {
        if (!initialized) {
            initialized = true;
        }
    }

    @Override
    public boolean isInitialized() {
        return initialized;
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }

    @Override
    public boolean autoConnect() {
        return autoConnect;
    }

    @Override
    public String url() {
        return url;
    }

    @Override
    public String clientId() {
        return clientId;
    }

    @Override
    public String userName() {
        return userName;
    }

    @Override
    public String password() {
        return password;
    }

    @Override
    public boolean cleanSession() {
        return cleanSession;
    }

    @Override
    public boolean manualAcks() {
        return manualAcks;
    }

    @Override
    public int connectionTimeout() {
        return connectionTimeout;
    }

    @Override
    public int keepAliveInterval() {
        return keepAliveInterval;
    }

    @Override
    public int maxInflight() {
        return maxInflight;
    }

    @Override
    public String version() {
        return version;
    }

    @Override
    public boolean automaticReconnection() {
        return automaticReconnection;
    }

    @Override
    public int reconnectDelay() {
        return reconnectDelay;
    }

    @Override
    public Properties sslProperties() {
        return sslProperties;
    }

    @Override
    public String storageDir() {
        return storageDir;
    }

    @Override
    public String willTopic() {
        return willTopic;
    }

    @Override
    public String willPayload() {
        return willPayload;
    }

    @Override
    public int willQos() {
        return willQos;
    }

    @Override
    public boolean willRetained() {
        return willRetained;
    }

    @Override
    public boolean isHasWill() {
        return StringUtils.isNotBlank(willTopic) && StringUtils.isNotBlank(willPayload);
    }

    public void setEnabled(boolean enabled) {
        if (!initialized) {
            this.enabled = enabled;
        }
    }

    public void setUrl(String url) {
        if (!initialized) {
            this.url = url;
        }
    }

    public void setClientId(String clientId) {
        if (!initialized) {
            this.clientId = clientId;
        }
    }

    public void setUserName(String userName) {
        if (!initialized) {
            this.userName = userName;
        }
    }

    public void setPassword(String password) {
        if (!initialized) {
            this.password = password;
        }
    }

    public void setCleanSession(boolean cleanSession) {
        if (!initialized) {
            this.cleanSession = cleanSession;
        }
    }

    public void setManualAcks(boolean manualAcks) {
        if (!initialized) {
            this.manualAcks = manualAcks;
        }
    }

    public void setConnectionTimeout(int connectionTimeout) {
        if (!initialized) {
            this.connectionTimeout = connectionTimeout;
        }
    }

    public void setKeepAliveInterval(int keepAliveInterval) {
        if (!initialized) {
            this.keepAliveInterval = keepAliveInterval;
        }
    }

    public void setMaxInflight(int maxInflight) {
        if (!initialized) {
            this.maxInflight = maxInflight;
        }
    }

    public void setVersion(String version) {
        if (!initialized) {
            this.version = version;
        }
    }

    public void setAutomaticReconnection(boolean automaticReconnection) {
        if (!initialized) {
            this.automaticReconnection = automaticReconnection;
        }
    }

    public void setReconnectDelay(int reconnectDelay) {
        if (!initialized) {
            this.reconnectDelay = reconnectDelay;
        }
    }

    public void setSslProperties(Properties sslProperties) {
        if (!initialized) {
            this.sslProperties = sslProperties;
        }
    }

    public void setStorageDir(String storageDir) {
        if (!initialized) {
            this.storageDir = storageDir;
        }
    }

    public void setWillTopic(String willTopic) {
        if (!initialized) {
            this.willTopic = willTopic;
        }
    }

    public void setWillPayload(String willPayload) {
        if (!initialized) {
            this.willPayload = willPayload;
        }
    }

    public void setWillQos(int willQos) {
        if (!initialized) {
            this.willQos = willQos;
        }
    }

    public void setWillRetained(boolean willRetained) {
        if (!initialized) {
            this.willRetained = willRetained;
        }
    }

    public void setAutoConnect(boolean autoConnect) {
        if (!initialized) {
            this.autoConnect = autoConnect;
        }
    }

    public static final class Builder {

        private final DefaultMqttConfig config = new DefaultMqttConfig();

        private Builder() {
        }

        public Builder enabled(boolean enabled) {
            config.setEnabled(enabled);
            return this;
        }

        public Builder url(String url) {
            config.setUrl(url);
            return this;
        }

        public Builder clientId(String clientId) {
            config.setClientId(clientId);
            return this;
        }

        public Builder userName(String userName) {
            config.setUserName(userName);
            return this;
        }

        public Builder password(String password) {
            config.setPassword(password);
            return this;
        }

        public Builder cleanSession(boolean cleanSession) {
            config.setCleanSession(cleanSession);
            return this;
        }

        public Builder manualAcks(boolean manualAcks) {
            config.setManualAcks(manualAcks);
            return this;
        }


        public Builder connectionTimeout(int connectionTimeout) {
            config.setConnectionTimeout(connectionTimeout);
            return this;
        }

        public Builder keepAliveInterval(int keepAliveInterval) {
            config.setKeepAliveInterval(keepAliveInterval);
            return this;
        }

        public Builder maxInflight(int maxInflight) {
            config.setMaxInflight(maxInflight);
            return this;
        }

        public Builder version(String version) {
            config.setVersion(version);
            return this;
        }

        public Builder automaticReconnection(boolean automaticReconnection) {
            config.setAutomaticReconnection(automaticReconnection);
            return this;
        }

        public Builder reconnectDelay(int reconnectDelay) {
            config.setReconnectDelay(reconnectDelay);
            return this;
        }

        public Builder sslProperties(Properties sslProperties) {
            config.setSslProperties(sslProperties);
            return this;
        }

        public Builder storageDir(String storageDir) {
            config.setStorageDir(storageDir);
            return this;
        }

        public Builder willTopic(String willTopic) {
            config.setWillTopic(willTopic);
            return this;
        }

        public Builder willPayload(String willPayload) {
            config.setWillPayload(willPayload);
            return this;
        }

        public Builder willQos(int willQos) {
            config.setWillQos(willQos);
            return this;
        }

        public Builder willRetained(boolean willRetained) {
            config.setWillRetained(willRetained);
            return this;
        }

        public Builder autoConnect(boolean autoConnect) {
            config.setAutoConnect(autoConnect);
            return this;
        }

        public DefaultMqttConfig build() {
            return config;
        }
    }
}